---
layout: blog
author: Alex
full-name: Alex Wing
short-title: academic-to-practical
full-title: Moving from academic to the practical code
file-type: html
publish-date: September 8
publish-year: 2021
card-color: green
---

<h1>Moving from academic to the practical code</h1>

<h2>Introduction</h2>
<p>It shocks me to my core even to say that It’s now been 2 years since I have graduated. In my mind, the time that feels
    like only last summer’s memories. Has in fact, whirled by fast. Leaving me with that same confused panicky
    feeling when you’re suddenly having to find that zoom unmute button at short notice. </p>

<p>There is a common thought that programming in academia isn’t the same as programming in industry. Whilst that is true
    that four years of programming theoretical questions involving console string interpellation isn’t going to help you
    implement a Heroku hosted web service application. I do believe there are some core fundamental skills and
    principles carry over.</p>

<p>With it now being over a year for me in this role. I wanted to take some time to openly reflect on just how
    divergent my style of coding has become since that sunny summer of 2018. My approach, attitude, thinking
    methodologies and even languages I use have all changed. But how much has it differed from acadmemic programming.</p>

<h2>Full specifications</h2>
<p>Specifications will never be the same as the ones you get in academia. It's heavenly to think of a customer giving
    an exact description of the problem, proposed solution, where to get marks, what to avoid, hints for added
    complexity to get bigger marks. These specifications in academia are the kind of that have been curated and
    refined over numerous years. Reaching levels of perfection due to years of students before, having asked all the
    questions necessary to leave little to the unknown.</p>

<p>A year in industry, has taught me specifications will very reach these levels of comprehensiveness. Specifications
    will be more  commonly be ambiguous, key core features will be said in passing work meetings. All the information is
    unlikely to be in formal documents and will require numerous iterations. Whilst this isn’t necessarily a
    negative as it gives some freedom to flex some creative muscles, introduce ideas and perhaps introduce new features
    and concepts that develop the proposal to a more refined solution.
    I often find specification and proposal research require a degree of patience and organisation. Formatting questions and
    exploring unknowns to get a full understanding is key. Without proper planning can result in either a long string of emails or
    long meetings. Which can be especially taxing to non-technical clients.</p>

<h2>Taking pride in the code you write</h2>
<p>Academic coding was always built to meet the needs of a single person. The reviewer. The code I was writing, was
    written in a style that I knew the reviewer would see themselves as “good code”. The naming of variables, the order
    of functions and how code executes. Whilst this teaches good practise principles, it can often be forgotten from
    memory quick as the submission is often never looked on again. Tests and maintainable code are never really
    considered. The transition over to industry standard coding practises has taught me the code you write should
    first and foremost be code you know can be understood when returned too. Motivation to write tested, maintainable,
    and documented code skyrockets. Client responses and feedback is often spaced out. Finding yourself coming back
    to code a few weeks old and not recalling much is a pretty common occurrence. Something of which I was quick to
    learn from</p>

<h2>Differing coding purposes</h2>
<p>The key difference between academic and industry software engineers is the lack of a “product” for customers.
    Academic code is often built to prove a point or showcase that something can be done. Often neglecting aspects
    of design, user experience and testing in favour of results and solutions. In contrast, a lot of my work now as a
    software engineer is analysing purpose, accessibility, and ease of use. Academia is often focused on the
    “theoretics and science of programming” where in contrast industry my focus has been on utilising tools and
    frameworks to produce things to be used by a wider audience</p>

<p>Furthermore, the transition between academic and industry has certainly has underlying similarities which add an aura of
    familiarity to what my daily work revolves around. I have found my focus changing, becoming a
    developer with 40-60% of my time on duties such as gathering and analysing requirements, testing, and
    prototyping. Something of which I was mainly told about, rather than experience fully during my degree.</p>

<h2>Working towards a common goal</h2>
<p>Any university graduate can tell you a story of a time with a horror group project, no matter the subject. People not
    collaborating, missed deadlines due to ineffective collaboration and even stealing others work. You hear it all
    during those university days sharing chats with friends. I often wondered why that is that these team projects often
    don’t work, whilst other unlikely teams succeeded astronomically. The pivotal point I now know being how effective
    the team are in working together towards a common goal.</p>

<p>In reflective comparison to my current role, the huge point of difference the software engineering methodology has
    to those group projects is shared ownership. Each member of our team feels responsible for an aspect of a system.
    Our work is intertwined with the help of a version control system merging our work together. This practise
    encourages responsibility and efficient collaboration as we all want to see the parts we developed working.
    Both in a sense individually and part of a wider scope. Often academic group projects were stagnated, with
    work being split up but only really brought together in a rush at the end. From taking on and learning effective
    working practises. I can see how we help overcome that as a team .With continuous review of features encouraged
    and committing changes into the mainstream of work giving a sense of shared ownership.
    This brings about an opportunity to not only collaborate our individual work, but review and learn from others too.</p>

<p>There are huge differences with the academic and industrial work. The fundamentals and the feedback given has
    no doubt lead me to be the programmer I am today.  There are practises I find myself recalling daily that help me in performing
    my role. I’m always learning more, at no point does the learning ever really end.</p>



